title:: Using SerialOSCClient
summary:: Notes on SuperCollider SerialOSC device (monome, arc) support provided by the SerialOSCClient library
categories:: External Control
related:: Classes/SerialOSCClient, Guides/UsingMIDI

Docs are incomplete and sometimes wrong. I'm working on it /Anton

section::Introduction

SerialOSCClient provides plug'n'play support for monome (link::http://monome.org::) grids, arcs and other SerialOSC compliant devices.

At its core link::Classes/SerialOSCClient:: and its related classes are to SerialOSC devices what link::Classes/MIDIClient:: and its related classes in the SuperCollider standard library are to MIDI devices.

In addition to this, it's possible to instantiate SerialOSCClient for the common single-grid, single-enc or one-grid-and-one-enc use cases. Each SerialOSCClient instance constitutes a self-contained client containing callback functions for refresh of leds and responding to incoming events using instance methods for continuous update of led state. Each client may be routed freely to any connected device using built-in routing capabilities, simplifying multi-app scenarios.

subsection::Basic Usage

Once initialized SerialOSCClient automatically discovers devices, maintains a list of connected devices in code::SerialOSCClient.connectedDevices:: and uses that list to route incoming events (key presses, encoder deltas, etc) to SerialOSC device specific responder objects (link::Classes/GridKeyFunc:: and link::Classes/GridKeydef:: for incoming grid key presses, link::Classes/EncDeltaFunc:: and link::Classes/EncDeltadef:: for encoder deltas, etc).

Instances of class link::Classes/SerialOSCGrid:: and link::Classes/SerialOSCEnc:: in the code::SerialOSCClient.connectedDevices:: list may be used to update led state of each connected device. SerialOSCClient automatically sets a default grid and arc the first time a device of either kind is attached. Led state of each default device can be updated using class methods in SerialOSCGrid and SerialOSCEnc.


subsection::Hello World

Initialize SerialOSCClient.

code::
SerialOSCClient.init;
::

Listen to button events:

code::
GridKeydef(\toggle, { |x, y, state, timestamp, device| [x, y, state, timestamp, device].postln }); // a press or release of any button on any connected grid will post event state information to Post Window
GridKeydef.press(\toggle).free; // free responder
::

Set led state:

code::
SerialOSCGrid.ledSet(0, 0, true); // set the top-leftmost led of default connected grid (if any) to lit
::

Let a specific button toggle its led:

code::
a=false; // toggle state, initially unlit
GridKeydef.press(\toggle, { SerialOSCGrid.ledSet(0, 0, a = a.not) }, 0, 0, 'default'); // a press on top-leftmost button on default grid will toggle its button led
GridKeydef.press(\toggle).free; // free responder
::

subsection::Clients

By instantiating SerialOSCClient, client logic is decoupled from what device(s) it is used for.

subsection::A Hello World Client

code::
(
// the toggle state example above as a client
c = SerialOSCClient.grid("Hello World") { |client|
	var state = false; // toggle state, initially unlit
	var updateLed = { client.ledSet(0, 0, state) }; // function that updates led state of button 0,0

	client.gridRefreshAction = updateLed; // when a new device is routed to this client led state will be updated

	client.gridKeyIndexPressedAction = { |x, y|
		if (x@y == 0@0) { // when button 0,0 is pressed,
			state = state.not; // state is toggled
			updateLed.value; // and led is refreshed
		}
	};
};
)

// this client will automatically be routed to a grid that is connected or gets connected later

c.unroute; // remove device-to-client routing

c.route(SerialOSCGrid.default); // state is maintained and leds refreshed when a new device is routed to the client

c.free; // or CmdPeriod frees client
::

section::Usage

subsection::Initialization

Before SerialOSC devices can be interacted with SerialOSCClient must be initialized. Just like code::MIDIClient.init:: initializes MIDIClient a call to method code::SerialOSCClient.init:: initializes SerialOSCClient.

code::
SerialOSCClient.init; // will probe for attached devices, autoconnect them, and automatically update device list upon devices being attached or detached
::

SerialOSCClient initialization is, unlike its MIDIClient equivalent, performed asynchronously. If code needs to be evaluated after initialization has completed a completionFunc may be supplied to the init method.

code::
// same as above but with a completion function
(
SerialOSCClient.init(completionFunc: {
	SerialOSCGrid.default.isNil.if { "No default grid is available!".warn }
});
)
::

subsection::Attached and connected devices

During initialization SerialOSCClient retrieves information on SerialOSC devices attached to the computer and stores an instance of SerialOSCGrid or SerialOSCEnc for each device in the code::SerialOSCClient.devices:: list. SerialOSCClient will only respond to devices connected to SerialOSCClient. All connected devices are maintined in the code::SerialOSCClient.connectedDevices:: list. SerialOSCClient by default autoconnects attached devices.

code::
SerialOSCClient.devices; // list of all devices attached to the computer
SerialOSCClient.connectedDevices; // list of all devices attached to the computer and connected to SerialOSCClient
::

SerialOSCGrid and SerialOSCEnc classes retain attached devices of each type in their code::*all:: lists.

code::
SerialOSCGrid.all; // all grid devices
SerialOSCEnc.all; // all encoder devices
::

It is possible to get notified of attached and connected devices using dependancy support. See link::Classes/SerialOSCGrid:: and link::Classes/SerialOSCEnc:: example code for details.

subsection::Responding to incoming events

A range of SerialOSC specific *Func and *def classes are used to respond to SerialOSC device events:

list::
## link::Classes/GridKeyFunc::
## link::Classes/GridKeydef::
## link::Classes/EncDeltaFunc::
## link::Classes/EncDeltadef::
## link::Classes/EncKeyFunc::
## link::Classes/EncKeydef::
## link::Classes/TiltFunc::
## link::Classes/Tiltdef::
::

For instance, link::Classes/GridKeyFunc:: is used to listen to key press events from connected grids:

code::
a=GridKeyFunc.press({ "Hello World".postln }); // pressing any button on an attached grid posts Hello World
b=GridKeyFunc.release({ "Bye, World".postln }); // releasing any button on an attached grid posts Bye, world
::

As with standard SuperCollider *Func and *def classes (link::Classes/MIDIFunc::/link::Classes/MIDIdef::/link::Classes/OSCFunc::/link::Classes/OSCdef::, etc), it's possible to filter SerialOSC *Func and *def objects by different properties such as x, y, state and device (for GridKeyFunc/def). If no filtering constraints are provided all events pass through.

code::
c=GridKeyFunc.press({ "Hello".postln }, 0, 0); // pressing top-leftmost button posts Hello
d=GridKeyFunc.release({ "Bye".postln }, 0, 0); // releasing top-leftmost button posts Bye

// pressing top-most button in second column auditions a sinewave
s.boot;
e=GridKeyFunc.press({ g = {SinOsc.ar(4000.exprand)}.play }, 1, 0);
f=GridKeyFunc.release({ g.release }, 1, 0);
::

Functions triggered by the responder object are passed details of the event type. All SerialOSC *Func and *def objects are passed an OSC timestamp and what device an event originated from. GridKeyFunc/def also pass x, y, state of the key event. Refer to the documentation of each class for further details on arguments.

code::
// pressing buttons in the third column will audition different degrees of default instrument
h=Array.fill(16);
i=GridKeyFunc.press({ |x, y, state, timestamp, device| h[y] = (degree: y).play }, 2);
j=GridKeyFunc.release({ |x, y, state, timestamp, device| h[y].release }, 2);
::

In multi-grid or multi-arc scenarios mapping to a device by id or to the default device of a kind using the 'default' symbol is needed to differentiate incoming events. In single-device scenarios this filter is typically omitted.

code::
k=GridKeyFunc.press({ |x, y, state, timestamp, device| "the default grid was pressed at" + x ++ "x" ++ y }, device: 'default');
l=GridKeyFunc.press({ |x, y, state, timestamp, device| "device with id 'm01231' was pressed at" + x ++ "x" ++ y }, device: \id -> 'm01231');
::

Responders may be freed individually or all-at-once.

code::
a.free; // free individual responder objects
b.free;

GridKeyFunc.freeAll; // free all GridKeyFunc responders
::

subsection::Updating led and ring state

Each attached device is reflected as a SerialOSCGrid or SerialOSCEnc instance with methods for updating led and ring state respectively.

code::
a=SerialOSCGrid.all.first; // assumes a grid is attached
a.ledSet(0, 1, true);
::

Leds of default SerialOSCGrid and SerialOSCEnc instances (if any) may also be updated using class methods.

code::
SerialOSCGrid.ledSet(4, 1, true); // a grid attached and set as default will receive this message

// ... is the same thing as...
SerialOSCGrid.default.notNil.if {
	SerialOSCGrid.default.ledSet(4, 1, true);
};

SerialOSCEnc.ringSet(0, 0, 15); // likewise, an encoder attached and set as default would receive this message
::

SerialOSC device instances can be obtained from the code::SerialOSCClient.devices::, code::SerialOSCClient.connectedDevices::, code::SerialOSCGrid.all:: or code::SerialOSCEnc.all:: lists or looked up in other ways using helper methods.

code::
a=SerialOSCGrid.all.first; // assumes a grid is attached
a.ledSet(0, 1, true);
a.ledSet(0, 1, false);

b=SerialOSCEnc.all.first; // assumes an encoder is attached
b.ringSet(0, 13, 15);
b.ringSet(0, 13, 0);

a=SerialOSCGrid.lookupById('m01234');
a.ledSet(SerialOSCGrid.xSpec.rand, SerialOSCGrid.ySpec.rand, [true, false].choose);
::

subsection::Default devices

Default grid and encoder devices are automatically set up the first time a device of either kind is attached and connected.

code::
SerialOSCGrid.default; // default grid
SerialOSCEnc.default; // default encoder
::

The default may be changed.

code::
SerialOSCGrid.default = SerialOSCGrid.all.choose; // if multiple devices are attached one of them is randomly selected as default
::

As shown above, default device led state may be set using class methods of SerialOSCGrid and SerialOSCEnc. For incoming events the special 'default' device may be used to create a filter that guarantees that only events from the the default grid or encoder is acted upon.

code::
// filter incoming events by a default grid using symbol 'default' as device
GridKeydef.press(\explicitDefaultPress, { |x, y| ("default grid was pressed at" + x ++ ", " ++ y).postln, device: 'default');

EncDeltadef(\explicitDefaultDelta, { |n, delta| ("default encoder's encoder " + n + " was turned " + delta).postln, device: 'default');
::

In single-device scenarios the device filter may be omitted since input events from any device (the one used) will pass through.

code::
GridKeydef.press(\pressFromAllDevices, { |x, y, state, device| ("grid" + device + "was pressed at" + x ++ ", " ++ y).postln);
::

section::Creating clients

For both simple and more advanced scenarios it's possible to create instances of SerialOSCClient, specify device configuration needed for each instance and rely on SerialOSCClient's built in capabilites for device-to-client routing. The advantages of this is that defaults or specific device ids, ports or prefixes need not be considered when developing an app for a SerialOSC compliant grid, arc or grid-and-arc configuration. Callback functions are provided to facilitate device refresh when new devices are routed and resource disposal when a client is freed.

Using built-in routing devices may freely be rerouted between different clients in an ad hoc fashion while multiple clients are concurrently running.

code::
x=SerialOSCClient.grid("My grid app"); // a possible default grid attached will be automatically routed to this client
(
x.onGridAttached = { |client| // onGotGrid, onGridFocused
	client.ledSet
};
x.onGridDetached = { |client| // onLostGrid, onLostGridFocus
	client.ledSet
};
x.gridKeyPressedAction = { |client, x, y, state|
};
x.gridKeyReleasedAction = { |client, x, y, state|
};
)
::

code::
// a possible default enc attached will be automatically routed to this client
y=SerialOSCClient.enc("My encoder app") { |client| // DSL style
	client.onEncAttached = { |client|
		client.ringSet
	};
	client.onEncDetached = { |client|
		client.ringSet
	};
	client.encDeltaAction = { |client, n, delta|
		client.ringSet
	};
}
::

code::
z=SerialOSCClient.gridEnc("An app that uses both grid and encoder");
(
z.onEncAttached = { |client|
	client.ringSet
};
z.onEncDetached = { |client|
	client.ringSet
};
z.encDeltaAction = { |client, n, delta|
	client.ringSet
};
)
::

code::
SerialOSCClient.all; // all clients

SerialOSCClient.route(SerialOSCGrid.default, z); // route programmatically
z.routeGrid(SerialOSCGrid.default); // route programmatically
SerialOSCClient.route(SerialOSCEnc.default, z);
z.routeGrid(SerialOSCEnc.default);

SerialOSCClient.unroute(SerialOSCGrid.default); // remove from its client
SerialOSCClient.unroute(SerialOSCEnc.default); // remove from its client

SerialOSCClient.routeGui; // graphical routing

x.remove;
y.remove;
z.remove;
::

subsection::Building apps for simple device configurations

With concepts outlined above it's in the simple case of building an app for one device or one of each type of device - one grid and one arc for example - possible to rely on default devices and implement an app without having to care for device ids, ports, prefixes, order, etc.

The simple toggle example below will update a grid with app state (the single toggle led state) even if the grid is not attached when the code is evaluated. If a single attached grid is reattached app state will also consistently be refreshed. If the default is changed, the app is updated accordingly on the new device.

code::
a=false; // initial toggle state

(
SerialOSCGrid.addDependant { |thechanged, what|
	if (what == 'default') {
		SerialOSCGrid.defaultLedSet(0, 0, a);
	};
};
)

(
GridKeydef.press(\toggle, { SerialOSCGrid.aljfddsafefaultLedSet(0, 0, a = a.not) }, 0, 0, 'default');
)
::

See app link::Examples/StepSequencer:: for a real life example of this.

subsection::Grid MVC

Alternative ways may be used to decouple values with the logic changing the value and the logic displaying the value. An example of this is using the Model-View-Controller design pattern.

By adjusting the toggle value example above slightly this can be achieved. The value is wrapped in a Ref to enable dependancy support for the underlying value (model). The led updaing logic is refactored to a listener of the value.

All three ways of changing the toggle state below - grid key press, code evaluation and in a forked loop - will result in a correctly updated led without the logic for changing value having to know about how the value is displayed.

code::
a=Ref(false); // initial toggle state is false

(
~toggleValue = { |value|
	a.value = value;
	a.changed;
};
)

(
b = SerialOSCClient.grid('mvc') { |client|
	var updateLed = { client.ledSet(0, 0, a.value) };
	a.addDependant = updateLed;
	client.gridRefreshedAction = updateLed;
	client.gridKeyPressedAction = { ~toggleValue.() }; // value can be changed by grid press
	client.onFree = { a.removeDependant(updateLed) }
}
)

// value can be changed by code evaluation
~toggleValue.();

(
// ... or in a forked loop
fork {
	8.do {
		~toggleValue.();
		0.5.wait;
	}
};
)

b.free; // or CmdPeriod to free client
::

section::Advanced

subsection::Using multiple devices

If several devices of the same type are to be used responder functions can be configured to filter a predetermined device.

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
GridKeydef.press(\grid1Press, { |x, y| "first grid pressed at %x%".format(x, y).postln }, device: a);
GridKeydef.press(\grid2Press, { |x, y| "second grid pressed at %x%".format(x, y).postln }, device: b);
::

Or...

code::
GridKeydef.press(\grid1Press, { |x, y| "first grid pressed at %x%".format(x, y).postln }, device: id -> 'm01');
GridKeydef.press(\grid2Press, { |x, y| "second grid pressed at %x%".format(x, y).postln }, device: id -> 'm02');
::

With multiple devices led state is typically not just sent to a default device but routed to predetermined devices depending on app logic.

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
a.ledSet(0, 0, true);
b.ledSet(6, 2, true);
::

An example of coupled operation

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
c=false;
d=false;

GridKeydef.press(\grid1Toggle, { |x, y| c = c.not; a.ledSet(0, 0, c) }, device: a);
GridKeydef.press(\grid2Toggle, { |x, y| d = d.not; b.ledSet(0, 0, d) }, device: b);
::

subsection::Disabling autodiscovery of devices

SerialOSCClient by default discovers attached and detached devices automatically and maintains an up-to-date list of devices in code::SerialOSCClient.devices::. Autodiscovery may be disabled by setting init's supportHotPlugging argument to false. When autodiscovery is disabled SerialOSCClient must be reinitialized in order to refresh the list of devices after device configuration has changed. Even with autodiscovery enabled reinitialization of SerialOSCClient is possible and may be needed if there are hiccups in the communication between the SerialOSC server daemon and SerialOSCClient.

subsection::Manually connecting devices

For a given device to work with SerialOSCClient classes a device not only has to be discovered and in the device list but also connected. Technically, when a device is connected to SerialOSCClient its prefix is set to "/sclang" and its destination port is set to the port SCLang is currently listening on (retrieved from code::NetAddr.langPort::, most often 57120).

Discovered devices are by default automatically connected. This may raise issues if you have multiple SerialOSC devices attached and only intend to use some of them for SuperCollider and others for other applications. You can tell SerialOSCClient to not automatically connect devices by setting code::SerialOSCClient.init::'s autoconnect argument to false. Devices will then have to be manually connected to SuperCollider using class method code::SerialOSCClient.connect:: or instance method code::SerialOSCDevice.connect::

code::

// example code for manually connecting a device
SerialOSCClient.init(autoconnect: false);

SerialOSCClient.connect('m0123'); // connect a device by id

a=SerialOSCClient.devices.first; // alternatively, lookup a device in the list...
a.connect; // ... and connect it
::

section::Classes

The main SerialOSC classes are:

list::
## link::Classes/SerialOSCClient::
## link::Classes/SerialOSCGrid::
## link::Classes/SerialOSCEnc::
## link::Classes/GridKeyFunc::
## link::Classes/GridKeydef::
## link::Classes/EncDeltaFunc::
## link::Classes/EncDeltadef::
## link::Classes/EncKeyFunc::
## link::Classes/EncKeydef::
## link::Classes/TiltFunc::
## link::Classes/Tiltdef::
::

section::Examples

See below code for intro:

subsection::Grids Intro Code
code::
// The !? idiom in SuperCollider (see help on !?) can be used to set leds of the default grid, but only if it is available (if SerialOSCGrid.default is not nil)

SerialOSCGrid.default !? { |grid| grid.ledSet(1, 2, true) };


// Now, on handling multiple devices

// Info on what device triggered a GridKeydef is available in the function argument list.
GridKeydef(\debug, { |x, y, state, time, device| [x, y, state, time, device].debug });

// You can use a device as filter. See OSCdef help for how this works.
GridKeydef(\debug, { |x, y, state, time, device| [x, y, state, time, device].debug }, device: SerialOSCGrid.default);

// If several devices are attached you can retrieve SerialOSCGrid and SerialOSCEnc instances from SerialOSCClient.devices
SerialOSCClient.devices;

// Pick a device and set a led
a=SerialOSCClient.devices.first;
a.ledSet(1, 2, true); // this assumes first device in list is a grid (SerialOSCGrid)
::

subsection::Hello Grid Buttons

code::
// Make sure to attach a SerialOSC compatible grid device to your computer.

SerialOSCClient.init; // Initialize the SerialOSCClient. Connected devices get posted to the Post Window.

s.boot; // Boot server

// Hello World - pressing the top-leftmost button on any attached grid auditions a sinewave.
GridKeydef.press(\playSine, { a = {SinOsc.ar}.play }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);

// Remove GridKeydefs using .free or by pressing Cmd-.
GridKeydef.press(\playSine).free;
GridKeydef.release(\stopSine).free;
::

subsection::Hello Grid Leds

code::
// Make sure to attach a SerialOSC compatible grid device to your computer.

SerialOSCClient.init; // Initialize the SerialOSCClient. Connected devices get posted to the Post Window.

a=SerialOSCGrid.default; // First attached grid is set as default
a.ledSet(0, 0, true); // Make top-leftmost led on the default grid lit
a.ledSet(0, 0, false); // Make top-leftmost led on the default grid unlit
8 do: { a.ledSet(8.rand, 8.rand, [true, false].choose) }; // Scramble 8 random leds in a 8x8 matrix
::

subsection::Hello Scrambled World

code::
(
var scrambleLeds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, [true, false].choose) };
	};
};

GridKeydef.press(\playSineAndScrambleLeds, { a = {SinOsc.ar}.play; scrambleLeds.(); }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);
)

GridKeydef.freeAll; // Free all responders
::

subsection::A monome and arc play together

code::
// Example, grid together with arc

(
var set_arc_led;
var scramble_8_grid_leds;
var b_spec = ControlSpec.new;

// Ensure server is running
s.serverRunning.not.if {
	Error("Boot server stored in interpreter variable s.").throw
};

// Initialize client in order to use devices
SerialOSCClient.init;

// SynthDef to server
SynthDef(\test, { |freq, gate=1| Out.ar(0, ( SinOsc.ar(Lag.kr(freq)) * EnvGen.ar(Env.cutoff, gate) ) ! 2) }).add;

// Function to visualize a float value 0 - 1.0 on first encoder ring of default arc (if attached)
set_arc_led = { |value|
	SerialOSCEnc.default !? { |enc|
		enc.clearRings;
		enc.ringSet(0, SerialOSCEnc.ledXSpec.map(value), 15);
	};
};

// Function to scramble state for 8 random buttons in a 8x8 led matrix on the default grid (if attached)
scramble_8_grid_leds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, [true, false].choose) };
	};
};

// Initial arc encoder setting
b = 0.5;
set_arc_led.(b);

// First Arc encoder control frequency of sinewave and scrambles 8 leds
EncDeltadef(\adjustFrequency, { |n, delta|
	b = b_spec.constrain(b + (delta/1000));
	a !? { a.set(\freq, \freq.asSpec.map(b)) };
	set_arc_led.(b);
	scramble_8_grid_leds.();
}, 0);

// Hitting any grid button auditions sinewave and scrambles 8 leds
GridKeydef.press(
	\playSine,
	{
		a ?? {
			a = Synth(\test, [\freq, \freq.asSpec.map(b)]);
			scramble_8_grid_leds.();
		};
	}
);

// Releasing any grid button stops the sinewave
GridKeydef.release(\stopSine, { a.release; a = nil });
)
::

section::Feedback

for suggestions / comments contact me

Anton Hörnquist, anton.hornquist@gmail.com.
