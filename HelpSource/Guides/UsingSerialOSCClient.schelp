title:: Using SerialOSCClient
summary:: Notes on SuperCollider SerialOSC device (monome, arc) support provided by the SerialOSCClient library
categories:: External Control
related:: Classes/SerialOSCClient, Guides/UsingMIDI

section::Introduction

SerialOSCClient provides plug'n'play support for monome (link::http://monome.org::) grids, arcs and other SerialOSC compliant devices.

At its core link::Classes/SerialOSCClient:: and its related classes are to SerialOSC devices what link::Classes/MIDIClient:: and its related classes in the SuperCollider standard library are to MIDI devices.

In addition to this, it's possible to instantiate SerialOSCClient for single-grid, single-enc or one-grid-and-one-enc use cases. SerialOSCClient instances constitute self-contained clients decoupled from the devices being used for the client. Callback functions are provided for led refresh and responding to incoming events. SerialOSCClient instance methods are used to update led state. Built-in routing is used to map devices to clients.

subsection::Hello World

Initialize SerialOSCClient.

code::
SerialOSCClient.init;
::

Set led state:

code::
SerialOSCGrid.ledSet(0, 0, 1); // set the top-leftmost led of default connected grid (first one connected) to lit
SerialOSCGrid.ledSet(0, 0, 0); // set the top-leftmost led of default connected grid (first one connected) to unlit
::

Listen to button events:

code::
GridKeydef(\test, { |x, y, state| (if (state == 1, "key down", "key up") + "at (%,%)".format(x, y)).postln }); // a press or release of any button on any connected grid will post event state information to Post Window
GridKeydef(\test).free; // or CmdPeriod frees responder
::

Let a specific button toggle its led:

code::
(
a=false; // led state, initially unlit
GridKeydef.press(\toggle, { SerialOSCGrid.ledSet(0, 0, a = a.not) }, 0, 0, 'default'); // a press on top-leftmost button on default grid will toggle its button led
)
GridKeydef.press(\toggle).free; // free responder
::

subsection::A Hello World Client

Self-contained clients are created by instantiating SerialOSCClient. This is recommended for single-grid, single-enc or one-grid-and-one-enc use.

code::
(
// the toggle state example above as a client
c = SerialOSCClient.grid("Hello World") { |client|
	var lit = false; // toggle state, initially unlit
	var updateLed = { client.ledSet(0, 0, lit) }; // function that updates led state of button 0,0

	client.gridRefreshAction = updateLed; // when a new device is routed to this client led state will be updated

	client.gridKeyAction = { |client, x, y, state|
        if ((x == 0) and: (y == 0) and: (state == 1)) { // when button 0,0 is pressed,
			lit = lit.not; // led state is toggled
			updateLed.value; // and led is refreshed
		}
	};
};
)

SerialOSCClient.postRoutings; // the client will automatically be routed to a grid connected to the computer

g=c.grid; // get routed grid
g.disconnect; // disconnecting routed grid from SerialOSCClient,
SerialOSCClient.postRoutings; // will detach it from the client

g.connect; // connecting the grid again,
SerialOSCClient.postRoutings; // will reroute it to the client and refresh the leds according to the current state of the client

c.free; // or CmdPeriod frees client
::

See more link::#Examples::.

section::Usage

subsection::Initialization

Before SerialOSC devices can be interacted with SerialOSCClient must be initialized. Just like code::MIDIClient.init:: initializes MIDIClient a call to method code::SerialOSCClient.init:: initializes SerialOSCClient.

code::
SerialOSCClient.init; // will probe for attached devices, autoconnect them, and automatically update device list upon devices getting attached or detached to the computer
::

Unlike MIDIClient, SerialOSCClient initialization is performed asynchronously. If code needs to be evaluated after initialization has completed a completionFunc may be supplied to the init method.

code::
// as above with a completion function
(
SerialOSCClient.init(completionFunc: {
	if (SerialOSCGrid.default.notNil) {
		SerialOSCGrid.default + "is the default grid.".postln;
	} {
		"No default grid is available.".postln;
	}
});
)
::

subsection::Discovering devices

During initialization SerialOSCClient retrieves information on SerialOSC devices currently attached to the computer and stores an instance of SerialOSCGrid or SerialOSCEnc for each device in the code::SerialOSCClient.devices:: list.

code::
SerialOSCClient.init;
SerialOSCClient.devices; // all devices attached to the computer
::

SerialOSCGrid and SerialOSCEnc classes also retain discovered devices of each type in their code::*all:: lists.

code::
SerialOSCGrid.all; // all grid devices connected to the computer
SerialOSCEnc.all; // all encoder devices connected to the computer
::

SerialOSCClient by default automatically updates the code::SerialOSCClient.devices:: list as devices are attached to and detached from the computer. This may be changed by setting argument code::autodiscover:: of init to false. See link::#Disabling discovery of devices::.

subsection::Default devices

Default grid and encoder devices are automatically set up the first time a device of either kind is attached and connected.

code::
SerialOSCGrid.default; // default grid
SerialOSCEnc.default; // default encoder
::

The default may be changed.

code::
SerialOSCGrid.default = SerialOSCGrid.all.choose; // if multiple grids are attached one of them is randomly set as default
::

subsection::Updating led and ring state

Each discovered device reflected as a SerialOSCGrid or SerialOSCEnc instance has methods for updating led and ring state.

code::
g=SerialOSCGrid.all.first; // assumes a grid is attached
g.ledSet(0, 1, 1);
g.ledSet(0, 1, 0);
g.ledSet(0, 1, true); // booleans works too
g.ledSet(0, 1, false);

e=SerialOSCEnc.all.first; // assumes an enc is attached
e.ringSet(0, 0, 15);
e.ringSet(0, 0, 0);
::

Leds of default SerialOSCGrid and SerialOSCEnc instances (if any) may be updated using class methods.

code::
SerialOSCGrid.ledSet(4, 1, true); // a grid attached and set as default will receive this message

// ... is the same thing as...
SerialOSCGrid.default.notNil.if {
	SerialOSCGrid.default.ledSet(4, 1, true);
};

SerialOSCEnc.ringSet(0, 0, 15); // an encoder attached and set as default will receive this message
::

subsection::Connecting devices

SerialOSCClient can update led state of any discovered device but can only respond to events from devices that are connected to SerialOSCClient. Devices are by default autoconnected as they are discovered.

code::
SerialOSCClient.connectedDevices; // list of all devices attached to the computer and connected to SerialOSCClient
::

Discovered grids and encs in the code::SerialOSCClient.devices:: list can explicitly be disconnected and connected.

code::
SerialOSCClient.default.isConnected; // if at least one grid is used they have been autoconnected and one is set as default
SerialOSCClient.connectedDevices; // all connected devices
SerialOSCClient.default.disconnect; // disconnect the default
SerialOSCClient.connectedDevices; // default is no longer in the list
SerialOSCClient.default.connect; // reconnect
SerialOSCClient.connectedDevices; // it's in the list again
::

subsection::Responding to incoming events

A range of SerialOSC specific *Func and *def classes are used to respond to events from devices connected to SerialOSCClient:

list::
## link::Classes/GridKeyFunc:: and link::Classes/GridKeydef:: responds to grid key state changes
## link::Classes/EncDeltaFunc:: and link::Classes/EncDeltadef:: responds to encoder position changes
## link::Classes/EncKeyFunc:: and link::Classes/EncKeydef:: responds to encoder key state changes
## link::Classes/TiltFunc:: and link::Classes/Tiltdef:: responds to grid tilt sensor changes
::

For instance, to listen to key state changes from a connected grid a link::Classes/GridKeyFunc:: responder may be used:

code::
a=GridKeyFunc.press({ "Hello World".postln }); // pressing any button on an attached grid posts Hello World
b=GridKeyFunc.release({ "Bye, World".postln }); // releasing any button on an attached grid posts Bye, world
::

As with standard SuperCollider *Func and *def classes (link::Classes/MIDIFunc::/link::Classes/MIDIdef::/link::Classes/OSCFunc::/link::Classes/OSCdef::, etc) it's possible to filter SerialOSC *Func and *def objects by different properties such as x, y, state and device (for GridKeyFunc/def). If no filtering constraints are provided all events pass through.

code::
c=GridKeyFunc.press({ "Hello".postln }, 0, 0); // pressing top-leftmost button posts Hello
d=GridKeyFunc.release({ "Bye".postln }, 0, 0); // releasing top-leftmost button posts Bye

// pressing top-most button in second column auditions a sinewave
s.boot;
e=GridKeyFunc.press({ g = {SinOsc.ar(4000.exprand)}.play }, 1, 0);
f=GridKeyFunc.release({ g.release }, 1, 0);
::

Functions triggered by the responder object are passed details of the event type. All SerialOSC *Func and *def objects are passed an OSC timestamp and what device an event originated from. GridKeyFunc/def also pass x, y, state of the key event. Refer to the documentation of each class for further details on arguments.

code::
// pressing buttons in the third column will audition different degrees of default instrument
h=Array.fill(16);
i=GridKeyFunc.press({ |x, y, state, timestamp, device| h[y] = (degree: y).play }, 2);
j=GridKeyFunc.release({ |x, y, state, timestamp, device| h[y].release }, 2);
::

In multi-grid or multi-arc scenarios mapping to a device by id or to the default device of a kind using the 'default' symbol is needed to differentiate incoming events.

code::
k=GridKeyFunc.press({ |x, y, state, timestamp, device| "the default grid was pressed at" + x ++ "x" ++ y }, device: 'default');
l=GridKeyFunc.press({ |x, y, state, timestamp, device| "device with id 'm01231' was pressed at" + x ++ "x" ++ y }, device: \id -> 'm01231');
::

Responders are freed individually, all-at-once or using CmdPeriod.

code::
a.free; // free individual responder object
b.free;

GridKeyFunc.freeAll; // free all GridKeyFunc responders
::

subsection::Device information

SerialOSCGrid and SerialOSCEnc instances provide some basic information of each device. 

code::
a=SerialOSCGrid.default; // assumes a grid is attached and set as default
a.id;
a.type;
a.port;
a.numCols;
a.numRows;
a.numCols; // cols taking rotation into account
a.numRows; // rows taking rotation into account
a.rotation;

a.rotation = 90;
a.numCols;
a.numRows;

b=SerialOSCEnc.default; // assumes an enc is attached and set as default
b.id;
b.type;
b.port;
b.numRings;
::

Specs describing grid bounds, enc ring numbers and led levels are also available.

code::
g=SerialOSCGrid.all.first;
g.ledXSpec; // per instance
g.ledYSpec; // per instance
SerialOSCGrid.ledXSpec; // ledXSpec of SerialOSCGrid.default, if any
SerialOSCGrid.ledYSpec; // ledXSpec of SerialOSCGrid.default, if any

e=SerialOSCEnc.all.first;
e.nSpec; // per instance
SerialOSCEnc.nSpec; // nSpec of SerialOSCEnc.default, if any

SerialOSCGrid.ledLSpec; // number of led intensity levels spec
SerialOSCEnc.ledLSpec; // number of led intensity levels spec

// in use
SerialOSCGrid.ledSet(SerialOSCGrid.xSpec.rand, SerialOSCGrid.ySpec.rand, [true, false].choose);

SerialOSCGrid.ledLevelSet(SerialOSCGrid.xSpec.rand, SerialOSCGrid.ySpec.rand, SerialOSCGrid.ledLSpec.rand);

// TODO: ledLSpec but level in arg?? either ledLevelSpec or l in arg. generic thing, s or state, etc
SerialOSCEnc.ringSet(SerialOSCenc.nSpec.rand, SerialOSCEnc.xSpec.rand, SerialOSCEnc.ledLSpec.choose);

(
fork {
	10.do {
		SerialOSCGrid.ledSet(SerialOSCGrid.xSpec.rand, SerialOSCGrid.ySpec.rand, [true, false].choose);
		SerialOSCEnc.ringRange(SerialOSCenc.nSpec.rand, SerialOSCEnc.xSpec.rand, SerialOSCEnc.xSpec.rand, SerialOSCEnc.ledLSpec.choose);
		0.1.wait;
	}
}
)
::

subsection::Device rotation

[TODO]

subsection::Enabling tilt sensors

[TODO]

section::Creating clients

It's recommended to create instances of SerialOSCClient for single-grid, single-enc or one-grid-and-one-enc use, specify device requirements needed for each instance and rely on SerialOSCClient's built in routing capabilites for mapping devices to a client. The advantages of this is that device ids, ports and prefixes need not be considered when developing an app for a SerialOSC compliant grid, arc or grid-and-arc configuration.

Callback functions are provided for clients to facilitate device refresh when new devices are routed and resource disposal when a client is freed.

code::
::

Instance methods are used to update led state.

code::
::

Callback functions are also provided for responding to incoming events.

code::
x=SerialOSCClient.grid("My grid app"); // a possible default grid attached will be automatically routed to this client
(
x.onGridAttached = { |client| // onGotGrid, onGridFocused
	client.ledSet
};
x.onGridDetached = { |client| // onLostGrid, onLostGridFocus
	client.ledSet
};
x.gridKeyPressedAction = { |client, x, y, state|
};
x.gridKeyReleasedAction = { |client, x, y, state|
};
)
::

code::
// a possible default enc attached will be automatically routed to this client
y=SerialOSCClient.enc("My encoder app") { |client| // DSL style
	client.onEncAttached = { |client|
		client.ringSet
	};
	client.onEncDetached = { |client|
		client.ringSet
	};
	client.encDeltaAction = { |client, n, delta|
		client.ringSet
	};
}
::

code::
z=SerialOSCClient.gridEnc("An app that uses both grid and encoder");
(
z.onEncAttached = { |client|
	client.ringSet
};
z.onEncDetached = { |client|
	client.ringSet
};
z.encDeltaAction = { |client, n, delta|
	client.ringSet
};
)
::

code::
SerialOSCClient.all; // all clients

SerialOSCClient.postRoutings; // see what devices are routed to clients

SerialOSCClient.route(SerialOSCGrid.default, z); // route programmatically
z.routeGrid(SerialOSCGrid.default); // route programmatically
SerialOSCClient.route(SerialOSCEnc.default, z);
z.routeGrid(SerialOSCEnc.default);

SerialOSCClient.unroute(SerialOSCGrid.default); // remove from its client
SerialOSCClient.unroute(SerialOSCEnc.default); // remove from its client

SerialOSCClient.routeGui; // graphical routing

x.remove;
y.remove;
z.remove;
::

subsection::Grid MVC

Alternative ways may be used to decouple values with the logic changing the value and the logic displaying the value. An example of this is using the Model-View-Controller design pattern.

By adjusting the toggle value example above slightly this can be achieved. The value is wrapped in a Ref to enable dependancy support for the underlying value (model). The led updaing logic is refactored to a listener of the value.

All three ways of changing the toggle state below - grid key press, code evaluation and in a forked loop - will result in a correctly updated led without the logic for changing value having to know about how the value is displayed.

code::
~state=Ref(false); // initial toggle state is false

(
~toggleValue = { |value|
	~state.value = value;
	~state.changed;
};
)
::

code::
(
b = SerialOSCClient.grid('grid mvc') { |client|
	var updateLed = { client.ledSet(0, 0, ~state.value) };
	~state.addDependant = updateLed; // when state is changed led is updated
	client.gridRefreshedAction = updateLed; // when a new grid is routed to this client led state is refreshed
	client.gridKeyPressedAction = { |client, x, y|
		if (x@y == 0@0) { ~toggleValue.value } // value can be changed by grid press
	};
	client.onFree = { ~state.removeDependant(updateLed) } // when client is freed the dependancy to state is removed
}
)
::

code::
~toggleValue.value; // value can be changed by code evaluation

(
// ... or in a forked loop
fork {
	8.do {
		~toggleValue.value;
		0.5.wait;
	}
};
)

b.free; // or CmdPeriod to free client
::

section::Advanced

subsection::Using multiple devices

If several devices of the same type are to be used responder functions can be configured to filter a predetermined device.

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
GridKeydef.press(\grid1Press, { |x, y| "first grid pressed at %x%".format(x, y).postln }, device: a);
GridKeydef.press(\grid2Press, { |x, y| "second grid pressed at %x%".format(x, y).postln }, device: b);
::

Or...

code::
GridKeydef.press(\grid1Press, { |x, y| "first grid pressed at %x%".format(x, y).postln }, device: id -> 'm01');
GridKeydef.press(\grid2Press, { |x, y| "second grid pressed at %x%".format(x, y).postln }, device: id -> 'm02');
::

With multiple devices led state is typically not just sent to a default device but routed to predetermined devices depending on app logic.

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
a.ledSet(0, 0, true);
b.ledSet(6, 2, true);
::

An example of coupled operation

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
c=false;
d=false;

GridKeydef.press(\grid1Toggle, { |x, y| c = c.not; a.ledSet(0, 0, c) }, device: a);
GridKeydef.press(\grid2Toggle, { |x, y| d = d.not; b.ledSet(0, 0, d) }, device: b);
::

subsection::Disabling device discovery

SerialOSCClient by default discovers attached and detached devices automatically and maintains an up-to-date list of devices in code::SerialOSCClient.devices::. Autodiscovery may be disabled by setting init's autodiscover argument to false. When autodiscovery is disabled SerialOSCClient must be reinitialized in order to refresh the list of devices after device configuration has changed. Even with autodiscovery enabled reinitialization of SerialOSCClient is possible and may be needed if there are hiccups in the communication between the SerialOSC server daemon and SerialOSCClient.

subsection::Manually connecting devices

To be able to respond to incoming events a device not only needs to be discovered but also connected to SuperCollider. Technically, when a device is connected to SerialOSCClient its prefix is set to "/monome" and its destination port is set to the port SCLang is currently listening on (retrieved from code::NetAddr.langPort::, most often 57120).

Discovered devices are by default automatically connected. This may raise issues if you have multiple SerialOSC devices attached and only intend to use some of them for SuperCollider and others for other applications. You can tell SerialOSCClient to not automatically connect devices by setting code::SerialOSCClient.init::'s autoconnect argument to false. Devices will then have to be manually connected to SuperCollider using class method code::SerialOSCClient.connect:: or instance method code::SerialOSCDevice.connect::

code::

// example code for manually connecting a device
SerialOSCClient.init(autoconnect: false);

SerialOSCClient.connect('m0123'); // connect a device by id

a=SerialOSCClient.devices.first; // alternatively, lookup a device in the list...
a.connect; // ... and connect it
::

subsection::Dependancy support

It is possible to get notified when devices are discovered, connected and routed using dependancy support.

See link::Classes/SerialOSCClient::, link::Classes/SerialOSCGrid:: and link::Classes/SerialOSCEnc:: example code for details.

section::Classes

The main SerialOSC classes are:

list::
## link::Classes/SerialOSCClient::
## link::Classes/SerialOSCGrid::
## link::Classes/SerialOSCEnc::
## link::Classes/GridKeyFunc::
## link::Classes/GridKeydef::
## link::Classes/EncDeltaFunc::
## link::Classes/EncDeltadef::
## link::Classes/EncKeyFunc::
## link::Classes/EncKeydef::
## link::Classes/TiltFunc::
## link::Classes/Tiltdef::
::

section::Examples

To try out these examples, make sure the serialosc server is running on your computer and a SerialOSC compatible grid or enc device is attached to your computer.

subsection::Hello Grid Leds

code::
SerialOSCClient.init;

SerialOSCGrid.ledSet(0, 0, true); // set top-leftmost led on the default grid lit
SerialOSCGrid.ledSet(0, 0, false); // set top-leftmost led on the default grid unlit
8 do: { SerialOSCGrid.ledSet(8.rand, 8.rand, [true, false].choose) }; // set 8 random leds in a 8x8 matrix
::

subsection::Grid Button Trigger Sine Wave

code::
SerialOSCClient.init;

s.boot; // Boot server

(
// pressing the top-leftmost button on any attached grid auditions a sinewave.
GridKeydef.press(\playSine, { a = {SinOsc.ar}.play }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);
)

(
// Remove GridKeydefs using .free or by pressing Cmd-.
GridKeydef.press(\playSine).free;
GridKeydef.release(\stopSine).free;
)
::

subsection::Hello Scrambled World

code::
(
var scrambleLeds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, [true, false].choose) };
	};
};

GridKeydef.press(\playSineAndScrambleLeds, { a = {SinOsc.ar}.play; scrambleLeds.(); }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);
)

GridKeydef.freeAll; // Free all responders
::

subsection::Hello Scrambled World (Varibright)

code::
(
var scrambleLeds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, SerialOSCGrid.ledLSpec.rand) };
	};
};

GridKeydef.press(\playSineAndScrambleLeds, { a = {SinOsc.ar}.play; scrambleLeds.(); }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);
)

GridKeydef.freeAll; // Free all responders
::

subsection::Visualize Incoming Audio

code::
(
c = SerialOSCClient.grid('in') { |client|
	var onReplyReceived;
	var synth;
	var responder;
	var values = Array.fill(8) { 0 };

	client.gridRefreshAction = {
		var convertValueToBitmask = { |amp|
			(amp * 8).asInteger.collect { |i| 1 << i }.sum
		};

		client.ledMap(0, 0, values.collect{ |v| convertValueToBitmask.value(v) })
	};

	client.onFree = { [synth, responder].do (_.free) };

	onReplyReceived = { |receivedValue|
		values=values.rotate;
		values[0]=receivedValue;
		client.refreshGrid;
	};

	Server.default.waitForBoot {
		responder = OSCFunc({ |msg| onReplyReceived.value(msg[3]) }, '/level');

		synth = {
			SendReply.kr(Impulse.kr(20), '/level', Amplitude.kr(SoundIn.ar(0), 0.01, 10), 1905); // TODO: 1905 ??
		}.play(Server.default);
	};
}
)

c.free;
::

subsection::A monome and arc play together

code::
// Example, grid together with arc

(
var set_arc_led;
var scramble_8_grid_leds;
var b_spec = ControlSpec.new;

// Ensure server is running
s.serverRunning.not.if {
	Error("Boot server stored in interpreter variable s.").throw
};

// Initialize client in order to use devices
SerialOSCClient.init;

// SynthDef to server
SynthDef(\test, { |freq, gate=1| Out.ar(0, ( SinOsc.ar(Lag.kr(freq)) * EnvGen.ar(Env.cutoff, gate) ) ! 2) }).add;

// Function to visualize a float value 0 - 1.0 on first encoder ring of default arc (if attached)
set_arc_led = { |value|
	SerialOSCEnc.default !? { |enc|
		enc.clearRings;
		enc.ringSet(0, SerialOSCEnc.ledXSpec.map(value), 15);
	};
};

// Function to scramble state for 8 random buttons in a 8x8 led matrix on the default grid (if attached)
scramble_8_grid_leds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, [true, false].choose) };
	};
};

// Initial arc encoder setting
b = 0.5;
set_arc_led.(b);

// First Arc encoder control frequency of sinewave and scrambles 8 leds
EncDeltadef(\adjustFrequency, { |n, delta|
	b = b_spec.constrain(b + (delta/1000));
	a !? { a.set(\freq, \freq.asSpec.map(b)) };
	set_arc_led.(b);
	scramble_8_grid_leds.();
}, 0);

// Hitting any grid button auditions sinewave and scrambles 8 leds
GridKeydef.press(
	\playSine,
	{
		a ?? {
			a = Synth(\test, [\freq, \freq.asSpec.map(b)]);
			scramble_8_grid_leds.();
		};
	}
);

// Releasing any grid button stops the sinewave
GridKeydef.release(\stopSine, { a.release; a = nil });
)
::

subsection::Step Sequencer

code::
(
~step = SerialOSCClient.grid('step') { |client|
	var tempoSpec = ControlSpec(20, 300, step: 1, default: 115);
	var swingAmountSpec = ControlSpec(0, 100, step: 1, default: 50);
	var synthDefName = 'step';

	var numSamples = 8;
	var numPatternSteps = 8;
	var patternBeats = 2;

	var buffers, trigs;
	var player, playpos;
	var tempo, swingAmount;
	var currentSwingOffset;

/*
	var adjustTempo = { |bpmDelta| // TODO: to be refactored outside of StepApp - Enc usage
		setTempo.value(tempo + bpmDelta);
	};

	var adjustSwingAmount = { |swingAmountDelta| // TODO: to be refactored outside of StepApp - Enc usage
		setSwingAmount.value(swingAmount + swingAmountDelta);
	};
*/

	var setTempo = { |bpm|
		tempo = tempoSpec.constrain(bpm);
		TempoClock.default.tempo_(tempo/60);
	};

	var setSwingAmount = { |amount|
		var maxSwingTimingOffset;
		maxSwingTimingOffset = (patternBeats/numPatternSteps)/2;
		swingAmount = swingAmountSpec.constrain(amount);
		currentSwingOffset = maxSwingTimingOffset * swingAmount / 100;
	};

	var clearPattern = {
		numSamples.do { |samplenum|
			numPatternSteps.do { |stepnum|
				trigIsSet.value(samplenum, stepnum).if { toggleTrig.value(samplenum, stepnum) };
			};
		};
	};

	var toggleTrig = { |samplenum, stepnum|
		var trig;
		trig = if (trigIsSet.value(samplenum, stepnum), \rest, 1);
		trigs[samplenum][stepnum] = trig;
	};

	var trigIsSet = { |samplenum, stepnum| trigs[samplenum][stepnum] == 1 };

	var spawnPattern = { |repeats, excludePlayposBumping=false|
		var sampleTriggering, timingAndSwing, playposBumping;

		timingAndSwing = Pbind(*[
			dur: Prout({
				var noSwingDur = patternBeats/numPatternSteps;
				(numPatternSteps/2) do: {
					var swingOffset;
					swingOffset = currentSwingOffset;
					(noSwingDur+swingOffset).yield;
					(noSwingDur-swingOffset).yield;
				};
				nil.yield;
			});
		]);

		excludePlayposBumping.not.if { // TODO: possibly remove, make this a ~step.changed(\playpos) or pattern.changed(\playpos) notification, or inject the tickFunc (onTick?) from spawnPattern argument to make this more clear
			playposBumping = Pbind(*[
				note: \rest,
				tickFunc: Prout({
					playpos = 0;
					loop {
						client.refreshGrid;
						if (playpos < (numPatternSteps-1)) { playpos = playpos + 1; } { nil }.yield;
					}
				})
			]);
		};

		sampleTriggering = buffers.collect { |buffer, i|
			Pbind(*[
				instrument: synthDefName,
				bufnum: buffer, // TODO: only play buffer if it has been fully loaded, to remedy "BOOOM" issues
				note: Pseq(trigs[i], 1)
			])
		};

		Ppar(
			(sampleTriggering ++ playposBumping).collect { |pattern| Pchain(pattern, timingAndSwing) },
			repeats
		);
	};

	var play = { |repeats=inf|
		player.isPlaying.if {
			"Already playing...".inform;
		} {
			player = if (player.isNil) {
				"Playing...".inform;
				spawnPattern.value(repeats).asEventStreamPlayer;
			} {
				"Resuming pattern".inform;
				player;
			};
			player.play(TempoClock.default);
		};
	};

	var stop = {
		player.isPlaying.if {
			player.stop;
			"...Stopped".inform;
		};
	};

	trigs = Array.fill2D(numSamples, numPatternSteps) { \rest };

	SynthDef(synthDefName, { |out = 0, bufnum|
		OffsetOut.ar( out, Pan2.ar(PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), doneAction: 2)) );
	}).add;

	s.waitForBoot {
		buffers = numSamples.collect { Buffer.new };

		client.onFree = { buffers.do(_.free) };

		client.gridRefreshAction = {
			client.ledMap(
				0,
				0,
				numSamples.collect { |samplenum|
					numPatternSteps.do.collect { |stepnum|
						if (trigIsSet.value(samplenum, stepnum) or: (playpos == stepnum)) { 1 << stepnum } { 0 };
					}.sum;
				}
			);
		};

		client.gridKeyAction = { |client, x, y, state|
			if (state.asBoolean) {
				toggleTrig.value(y, x);
				client.refreshGrid;
			};
		};

		client.addUniqueMethod(\loadSample) { |client, samplenum, path|
			buffers[samplenum].allocReadChannel(path, channels: [0], completionMessage: {
				this.changed(\sampleWasLoaded, samplenum, path);
			}); // TODO: look into making a PR for completionMessage bug
		};

		client.addUniqueMethod(\toggleTrig) { |client, samplenum, path| toggleTrig.value(samplenum, path) };
		client.addUniqueMethod(\playSequencer) { |client, samplenum, path| play.value };
		client.addUniqueMethod(\stopSequencer) { |client, samplenum, path| stop.value };
		client.addUniqueMethod(\swingAmount_) { |client, amount| setSwingAmount.value(amount) };
		client.addUniqueMethod(\tempo_) { |client, bpm| setTempo.value(bpm) };
		client.addUniqueMethod(\getPattern) { |client, repeats| spawnPattern.value(repeats, true).deepCopy };

		setTempo.value(tempoSpec.default);
		setSwingAmount.value(swingAmountSpec.default);

		play.value;
	};
};
)
::

See link::Guides/StepSequencerExample:: for details on how to use this step sequencer.

subsection::Clip Launcher

code::
(
~clip = SerialOSCClient.grid('clip') { |client|
	var playingLedLevel = 15;
	var queuedLedLevel = 6;
	var loadedLedLevel = 3;
	var numTracks = 15;
	var numSlotsPerTrack = 15;
	var quant = 1;
	var slice = 0.01; // slice must be less than quant
	var listeners;

	var patterns = Array.fill2D(numTracks, numSlotsPerTrack);
	var players = Array.fill2D(numTracks, numSlotsPerTrack);
	var queueRoutines = Array.fill(numTracks);
	var queuedSlots = Array.fill(numTracks);
	var playingSlots = Array.fill(numTracks);

	var numVisibleTracks = { min(numTracks, client.grid.numCols-1) };

	var playSlot = { |trackIndex, slotIndex|
		patterns[trackIndex][slotIndex].notNil.if {
			stopQueued.value(trackIndex);
			queueSlot.value(trackIndex, slotIndex);
			refreshTrackLeds.value(trackIndex);
		} {
			stopTrack.value(trackIndex);
		}
	};

	var queueSlot = { |trackIndex, slotIndex|
		var routine = Routine {
			var pattern;
			var player;
			var stopListener;
			pattern = patterns[trackIndex][slotIndex];
			stopListener = { |player, what|
			case
			{ [\stopped, \userStopped].includes(what) } {
				player.removeDependant(stopListener);
				playingSlots[trackIndex] = nil;
				refreshTrackLeds.value(trackIndex);
			}
			};

			playingSlots[trackIndex].notNil.if {
				var slotIndex = playingSlots[trackIndex];
				players[trackIndex][slotIndex].stop;
			};

			slice.wait;

			player = pattern.play;
			player.addDependant(stopListener);

			players[trackIndex][slotIndex] = player;
			queuedSlots[trackIndex] = nil;
			playingSlots[trackIndex] = slotIndex;
			refreshTrackLeds.value(trackIndex);
		};

		queueRoutines[trackIndex] = routine;
		routine.play(quant: [quant, (-1) * slice]);
		queuedSlots[trackIndex] = slotIndex;
	};

	var refreshTrackLeds = { |trackIndex|
		client.grid !? { |grid|
			if (trackIndex < (grid.numCols-1)) {
				(grid.numRows-1).do { |slotIndex|
					var level = if (slotIndex <= numSlotsPerTrack) {
						case
						{ playingSlots[trackIndex] == slotIndex } { playingLedLevel }
						{ queuedSlots[trackIndex].value == slotIndex } { queuedLedLevel }
						{ patterns[trackIndex][slotIndex].notNil } { loadedLedLevel }
						} ? 0;
					client.ledLevelSet(trackIndex, slotIndex, level);
				};
			};
		};
	};

	var stopTrack = { |trackIndex|
		stopQueued.value(trackIndex);
		stopPlaying.value(trackIndex);
	};

	var stopQueued = { |trackIndex|
		queuedSlots[trackIndex] !? { |slotIndex|
			queueRoutines[trackIndex].stop;
			queuedSlots[trackIndex] = nil;
		};
	};

	var stopPlaying = { |trackIndex|
		playingSlots[trackIndex] !? { |slotIndex|
			var routine = Routine { // TODO: possibly need to save this routine to not interfer with new queued play action of same slot
				players[trackIndex][slotIndex].stop;
			};
			routine.play(quant: [quant, (-1) * slice]);
		};
	};

	// client.gridRotationChangedAction = { |client| }; // TODO: not sure if anything is needed here, assuming gridRefreshAction is triggered?

	client.onGridRouted = { |client| }; // TODO: check client is argument in SerialOSCClient

	client.onFree = { numTracks.do { |i| stopTrack.value(i) } };

	client.addUniqueMethod(\load) { |client, trackIndex, slotIndex, pattern|
		stopPlaying.value(trackIndex);
		patterns[trackIndex][slotIndex] = pattern;
		client.grid !? { |grid|
			if ( (trackIndex < (grid.numCols-1)) and: (slotIndex < (grid.numRows-1)) ) {
				client.ledLevelSet(trackIndex, slotIndex, loadedLedLevel);
			};
		};
	};

	client.addUniqueMethod(\quant_) { |client, argQuant| quant = argQuant };

	s.waitForBoot {
		client.gridKeyAction = { |client, x, y, state, timestamp|
			case
			{ state.asBoolean and: (y < (client.grid.numRows-1)) } {
				case
				{ x < numVisibleTracks.value } { playSlot.value(x, y) }
				{ x == (client.grid.numCols-1) } {
					numVisibleTracks.value.do { |trackIndex| playSlot.value(trackIndex, y) }
				}
			}
			{ state.asBoolean and: (y == (client.grid.numRows-1))} {
				case
				{ x < numVisibleTracks.value } { stopTrack.value(x) }
				{ x == (client.grid.numCols-1) } {
					numVisibleTracks.value.do { |trackIndex| stopTrack.value(trackIndex) }
				}
			};
		};

		client.gridRefreshAction = { |client| // TODO: check client is argument in SerialOSCClient
			numVisibleTracks.value.do { |trackIndex| refreshTrackLeds.value(trackIndex) };
		};

		client.addUniqueMethod(\play) { |client, trackIndex, slotIndex| playSlot.value(trackIndex, slotIndex) };

		client.grid !? { client.refreshGrid };
	}
};
)
::

See link::Guides/ClipExample:: for details on how to use this step sequencer.

section::Feedback

for suggestions / comments contact me

Anton Hörnquist, anton.hornquist@gmail.com.
