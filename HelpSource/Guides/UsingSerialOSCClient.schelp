title:: Using SerialOSCClient
summary:: Notes on SuperCollider SerialOSC device (monome, arc) support provided by the SerialOSCClient library
categories:: External Control
related:: Classes/SerialOSCClient, Guides/UsingMIDI

section::Introduction

SerialOSCClient provides plug'n'play support for monome (link::http://monome.org::) grids, arcs and other SerialOSC compliant devices.

At its core link::Classes/SerialOSCClient:: and its related classes are to SerialOSC devices what link::Classes/MIDIClient:: and its related classes in the SuperCollider standard library are to MIDI devices.

In addition to this, it's possible to instantiate SerialOSCClient for single-grid, single-enc or one-grid-and-one-enc use cases. SerialOSCClient instances constitute self-contained clients decoupled from the device it is using. Callback functions are provided for led refresh and responding to incoming events. SerialOSCClient instance methods are used to update led state. Built-in routing capabilities are used to map devices to clients.

subsection::Basic Usage

Once initialized SerialOSCClient automatically discovers devices attached to the computer and maintains a list of devices currently attached in the code::SerialOSCClient.devices:: list.

Instances of class link::Classes/SerialOSCGrid:: and link::Classes/SerialOSCEnc:: in the code::SerialOSCClient.devices:: list may be used to update led state of each connected device. SerialOSCClient automatically sets a default grid and arc the first time a device of either kind is attached. Led state of each default device can be updated using class methods in SerialOSCGrid and SerialOSCEnc.

By default SerialOSCClient also changes each attached device destination port to SuperCollider's langPort, message prefix to "/monome" and includes the device in the code::SerialOSCClient.connectedDevices:: list effectively connecting the device to SuperCollider. Incoming events (key presses, encoder deltas, etc) of each connected device is routed to SerialOSC device specific responder objects (link::Classes/GridKeyFunc:: and link::Classes/GridKeydef:: for incoming grid key presses, link::Classes/EncDeltaFunc:: and link::Classes/EncDeltadef:: for encoder deltas, etc).


subsection::Hello World

Initialize SerialOSCClient.

code::
SerialOSCClient.init;
::

Set led state:

code::
SerialOSCGrid.ledSet(0, 0, true); // set the top-leftmost led of default connected grid (if any) to lit
::

Listen to button events:

code::
GridKeydef(\toggle, { |x, y, state, timestamp, device| [x, y, state, timestamp, device].postln }); // a press or release of any button on any connected grid will post event state information to Post Window
GridKeydef(\toggle).free; // free responder
::

Let a specific button toggle its led:

code::
a=false; // toggle state, initially unlit
GridKeydef.press(\toggle, { SerialOSCGrid.ledSet(0, 0, a = a.not) }, 0, 0, 'default'); // a press on top-leftmost button on default grid will toggle its button led
GridKeydef.press(\toggle).free; // free responder
::

subsection::Instantiating a client

By instantiating SerialOSCClient self-contained clients are created. This is recommended for single-grid, single-enc or one-grid-and-one-enc use.

subsection::A Hello World Client

code::
(
// the toggle state example above as a client
c = SerialOSCClient.grid("Hello World") { |client|
	var state = false; // toggle state, initially unlit
	var updateLed = { client.ledSet(0, 0, state) }; // function that updates led state of button 0,0

	client.gridRefreshAction = updateLed; // when a new device is routed to this client led state will be updated

	client.gridKeyIndexPressedAction = { |x, y|
		if (x@y == 0@0) { // when button 0,0 is pressed,
			state = state.not; // state is toggled
			updateLed.value; // and led is refreshed
		}
	};
};
)

// this client will automatically be routed to a grid that is connected or gets connected later

c.unroute; // remove device-to-client routing

c.route(SerialOSCGrid.default); // state is maintained and leds refreshed when a new device is routed to the client

c.free; // or CmdPeriod frees client
::

section::Usage

subsection::Initialization

Before SerialOSC devices can be interacted with SerialOSCClient must be initialized. Just like code::MIDIClient.init:: initializes MIDIClient a call to method code::SerialOSCClient.init:: initializes SerialOSCClient.

code::
SerialOSCClient.init; // will probe for attached devices, autoconnect them, and automatically update device list upon devices getting attached or detached to the computer
::

SerialOSCClient initialization is, unlike MIDIClient, performed asynchronously. If code needs to be evaluated after initialization has completed a completionFunc may be supplied to the init method.

code::
// as above with a completion function
(
SerialOSCClient.init(completionFunc: {
	SerialOSCGrid.default.isNil.if { "No default grid is available!".warn }
});
)
::

subsection::Discovering and connecting devices

During initialization SerialOSCClient retrieves information on SerialOSC devices currently attached to the computer and stores an instance of SerialOSCGrid or SerialOSCEnc for each device in the code::SerialOSCClient.devices:: list.

code::
SerialOSCClient.init;
SerialOSCClient.devices; // list of all devices attached to the computer
::

SerialOSCGrid and SerialOSCEnc classes also retain discovered devices of each type in their code::*all:: lists.

code::
SerialOSCGrid.all; // all grid devices
SerialOSCEnc.all; // all encoder devices
::

SerialOSCGrid and SerialOSCEnc instances in the code::*devices:: or code::*all:: lists may be used for update of led state.

SerialOSCClient will only respond to devices that are connected to SerialOSCClient. Connected devices are maintined in the code::SerialOSCClient.connectedDevices:: list.

code::
SerialOSCClient.connectedDevices; // list of all devices attached to the computer and connected to SerialOSCClient
::

SerialOSCClient by default autoconnects devices as they are discovered.

It is possible to get notified of discovered and connected devices using dependancy support. See link::Classes/SerialOSCGrid:: and link::Classes/SerialOSCEnc:: example code for details.

subsection::Default devices

Default grid and encoder devices are automatically set up the first time a device of either kind is attached and connected.

code::
SerialOSCGrid.default; // default grid
SerialOSCEnc.default; // default encoder
::

The default may be changed.

code::
SerialOSCGrid.default = SerialOSCGrid.all.choose; // if multiple devices are attached one of them is randomly selected as default
::

subsection::Updating led and ring state

Each discovered device is reflected as a SerialOSCGrid or SerialOSCEnc instance with methods for updating led and ring state respectively.

code::
a=SerialOSCGrid.all.first; // assumes a grid is attached
a.ledSet(0, 1, true);
::

Leds of default SerialOSCGrid and SerialOSCEnc instances (if any) may be updated using class methods.

code::
SerialOSCGrid.ledSet(4, 1, true); // a grid attached and set as default will receive this message

// ... is the same thing as...
SerialOSCGrid.default.notNil.if {
	SerialOSCGrid.default.ledSet(4, 1, true);
};

SerialOSCEnc.ringSet(0, 0, 15); // likewise, an encoder attached and set as default would receive this message
::

SerialOSC device instances can be obtained from the code::SerialOSCClient.devices::, code::SerialOSCClient.connectedDevices::, code::SerialOSCGrid.all:: or code::SerialOSCEnc.all:: lists or looked up in other ways using helper methods.

code::
a=SerialOSCGrid.all.first; // assumes a grid is attached
a.ledSet(0, 1, true);
a.ledSet(0, 1, false);

b=SerialOSCEnc.all.first; // assumes an encoder is attached
b.ringSet(0, 13, 15);
b.ringSet(0, 13, 0);

a=SerialOSCGrid.lookupById('m01234');
a.ledSet(SerialOSCGrid.xSpec.rand, SerialOSCGrid.ySpec.rand, [true, false].choose);
::

subsection::Responding to incoming events

A range of SerialOSC specific *Func and *def classes are used to respond to SerialOSC device events from any device connected to SerialOSCClient:

list::
## link::Classes/GridKeyFunc:: and link::Classes/GridKeydef:: responds to grid key state changes
## link::Classes/EncDeltaFunc:: and link::Classes/EncDeltadef:: responds to encoder position changes
## link::Classes/EncKeyFunc:: and link::Classes/EncKeydef:: responds to encoder key state changes
## link::Classes/TiltFunc:: and link::Classes/Tiltdef:: responds to grid tilt sensor changes
::

For instance, to listen to key state changes from a connected grid link::Classes/GridKeyFunc:: may be used:

code::
a=GridKeyFunc.press({ "Hello World".postln }); // pressing any button on an attached grid posts Hello World
b=GridKeyFunc.release({ "Bye, World".postln }); // releasing any button on an attached grid posts Bye, world
::

As with standard SuperCollider *Func and *def classes (link::Classes/MIDIFunc::/link::Classes/MIDIdef::/link::Classes/OSCFunc::/link::Classes/OSCdef::, etc), it's possible to filter SerialOSC *Func and *def objects by different properties such as x, y, state and device (for GridKeyFunc/def). If no filtering constraints are provided all events pass through.

code::
c=GridKeyFunc.press({ "Hello".postln }, 0, 0); // pressing top-leftmost button posts Hello
d=GridKeyFunc.release({ "Bye".postln }, 0, 0); // releasing top-leftmost button posts Bye

// pressing top-most button in second column auditions a sinewave
s.boot;
e=GridKeyFunc.press({ g = {SinOsc.ar(4000.exprand)}.play }, 1, 0);
f=GridKeyFunc.release({ g.release }, 1, 0);
::

Functions triggered by the responder object are passed details of the event type. All SerialOSC *Func and *def objects are passed an OSC timestamp and what device an event originated from. GridKeyFunc/def also pass x, y, state of the key event. Refer to the documentation of each class for further details on arguments.

code::
// pressing buttons in the third column will audition different degrees of default instrument
h=Array.fill(16);
i=GridKeyFunc.press({ |x, y, state, timestamp, device| h[y] = (degree: y).play }, 2);
j=GridKeyFunc.release({ |x, y, state, timestamp, device| h[y].release }, 2);
::

In multi-grid or multi-arc scenarios mapping to a device by id or to the default device of a kind using the 'default' symbol is needed to differentiate incoming events.

code::
k=GridKeyFunc.press({ |x, y, state, timestamp, device| "the default grid was pressed at" + x ++ "x" ++ y }, device: 'default');
l=GridKeyFunc.press({ |x, y, state, timestamp, device| "device with id 'm01231' was pressed at" + x ++ "x" ++ y }, device: \id -> 'm01231');
::

Responders are freed individually or all-at-once or using CmdPeriod.

code::
a.free; // free individual responder objects
b.free;

GridKeyFunc.freeAll; // free all GridKeyFunc responders
::

subsection::Device information

SerialOSCGrid and SerialOSCEnc instances provide some basic information of each device. 

code::
a=SerialOSCGrid.default; // assumes a grid is attached and set as default
a.id;
a.type;
a.port;
a.numCols;
a.numRows;
a.getEffectiveNumCols; // cols taking rotation into account
a.getEffectiveNumRows; // rows taking rotation into account
a.rotation;

a.rotation = 90;
a.getEffectiveNumCols;
a.getEffectiveNumRows;

b=SerialOSCEnc.default; // assumes an enc is attached and set as default
b.id;
b.type;
b.port;
b.numRings;
::

section::Creating clients

It's recommended to create instances of SerialOSCClient for single-grid, single-enc or one-grid-and-one-enc use, specify device requirements needed for each instance and rely on SerialOSCClient's built in routing capabilites for mapping devices to a client. The advantages of this is that device ids, ports and prefixes need not be considered when developing an app for a SerialOSC compliant grid, arc or grid-and-arc configuration.

Callback functions are provided for clients to facilitate device refresh when new devices are routed and resource disposal when a client is freed. Instance methods are used to update led state. Callback functions are also provided for responding to incoming events.

code::
x=SerialOSCClient.grid("My grid app"); // a possible default grid attached will be automatically routed to this client
(
x.onGridAttached = { |client| // onGotGrid, onGridFocused
	client.ledSet
};
x.onGridDetached = { |client| // onLostGrid, onLostGridFocus
	client.ledSet
};
x.gridKeyPressedAction = { |client, x, y, state|
};
x.gridKeyReleasedAction = { |client, x, y, state|
};
)
::

code::
// a possible default enc attached will be automatically routed to this client
y=SerialOSCClient.enc("My encoder app") { |client| // DSL style
	client.onEncAttached = { |client|
		client.ringSet
	};
	client.onEncDetached = { |client|
		client.ringSet
	};
	client.encDeltaAction = { |client, n, delta|
		client.ringSet
	};
}
::

code::
z=SerialOSCClient.gridEnc("An app that uses both grid and encoder");
(
z.onEncAttached = { |client|
	client.ringSet
};
z.onEncDetached = { |client|
	client.ringSet
};
z.encDeltaAction = { |client, n, delta|
	client.ringSet
};
)
::

code::
SerialOSCClient.all; // all clients

SerialOSCClient.postRoutings; // see what devices are routed to clients

SerialOSCClient.route(SerialOSCGrid.default, z); // route programmatically
z.routeGrid(SerialOSCGrid.default); // route programmatically
SerialOSCClient.route(SerialOSCEnc.default, z);
z.routeGrid(SerialOSCEnc.default);

SerialOSCClient.unroute(SerialOSCGrid.default); // remove from its client
SerialOSCClient.unroute(SerialOSCEnc.default); // remove from its client

SerialOSCClient.routeGui; // graphical routing

x.remove;
y.remove;
z.remove;
::

subsection::Grid MVC

Alternative ways may be used to decouple values with the logic changing the value and the logic displaying the value. An example of this is using the Model-View-Controller design pattern.

By adjusting the toggle value example above slightly this can be achieved. The value is wrapped in a Ref to enable dependancy support for the underlying value (model). The led updaing logic is refactored to a listener of the value.

All three ways of changing the toggle state below - grid key press, code evaluation and in a forked loop - will result in a correctly updated led without the logic for changing value having to know about how the value is displayed.

code::
~state=Ref(false); // initial toggle state is false

(
~toggleValue = { |value|
	~state.value = value;
	~state.changed;
};
)

(
b = SerialOSCClient.grid('mvc') { |client|
	var updateLed = { client.ledSet(0, 0, ~state.value) };
	~state.addDependant = updateLed; // when state is changed led is updated
	client.gridRefreshedAction = updateLed; // when a new grid is reouted led state is refreshed
	client.gridKeyPressedAction = { |client, x, y|
		if (x@y == 0@0) { ~toggleValue.value } // value can be changed by grid press
	};
	client.onFree = { ~state.removeDependant(updateLed) } // when client is freed the dependancy to state is removed
}
)

~toggleValue.value; // value can be changed by code evaluation

(
// ... or in a forked loop
fork {
	8.do {
		~toggleValue.value;
		0.5.wait;
	}
};
)

b.free; // or CmdPeriod to free client
::

section::Advanced

subsection::Using multiple devices

If several devices of the same type are to be used responder functions can be configured to filter a predetermined device.

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
GridKeydef.press(\grid1Press, { |x, y| "first grid pressed at %x%".format(x, y).postln }, device: a);
GridKeydef.press(\grid2Press, { |x, y| "second grid pressed at %x%".format(x, y).postln }, device: b);
::

Or...

code::
GridKeydef.press(\grid1Press, { |x, y| "first grid pressed at %x%".format(x, y).postln }, device: id -> 'm01');
GridKeydef.press(\grid2Press, { |x, y| "second grid pressed at %x%".format(x, y).postln }, device: id -> 'm02');
::

With multiple devices led state is typically not just sent to a default device but routed to predetermined devices depending on app logic.

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
a.ledSet(0, 0, true);
b.ledSet(6, 2, true);
::

An example of coupled operation

code::
a=SerialOSCGrid.lookupById('m01');
b=SerialOSCGrid.lookupById('m02');
c=false;
d=false;

GridKeydef.press(\grid1Toggle, { |x, y| c = c.not; a.ledSet(0, 0, c) }, device: a);
GridKeydef.press(\grid2Toggle, { |x, y| d = d.not; b.ledSet(0, 0, d) }, device: b);
::

subsection::Disabling discovery of devices

SerialOSCClient by default discovers attached and detached devices automatically and maintains an up-to-date list of devices in code::SerialOSCClient.devices::. Autodiscovery may be disabled by setting init's autodiscover argument to false. When autodiscovery is disabled SerialOSCClient must be reinitialized in order to refresh the list of devices after device configuration has changed. Even with autodiscovery enabled reinitialization of SerialOSCClient is possible and may be needed if there are hiccups in the communication between the SerialOSC server daemon and SerialOSCClient.

subsection::Manually connecting devices

To be able to respond to incoming events a device not only needs to be discovered but also connected to SuperCollider. Technically, when a device is connected to SerialOSCClient its prefix is set to "/monome" and its destination port is set to the port SCLang is currently listening on (retrieved from code::NetAddr.langPort::, most often 57120).

Discovered devices are by default automatically connected. This may raise issues if you have multiple SerialOSC devices attached and only intend to use some of them for SuperCollider and others for other applications. You can tell SerialOSCClient to not automatically connect devices by setting code::SerialOSCClient.init::'s autoconnect argument to false. Devices will then have to be manually connected to SuperCollider using class method code::SerialOSCClient.connect:: or instance method code::SerialOSCDevice.connect::

code::

// example code for manually connecting a device
SerialOSCClient.init(autoconnect: false);

SerialOSCClient.connect('m0123'); // connect a device by id

a=SerialOSCClient.devices.first; // alternatively, lookup a device in the list...
a.connect; // ... and connect it
::

section::Classes

The main SerialOSC classes are:

list::
## link::Classes/SerialOSCClient::
## link::Classes/SerialOSCGrid::
## link::Classes/SerialOSCEnc::
## link::Classes/GridKeyFunc::
## link::Classes/GridKeydef::
## link::Classes/EncDeltaFunc::
## link::Classes/EncDeltadef::
## link::Classes/EncKeyFunc::
## link::Classes/EncKeydef::
## link::Classes/TiltFunc::
## link::Classes/Tiltdef::
::

section::Examples

See below code for intro:

subsection::Grids Intro Code
code::
// The !? idiom in SuperCollider (see help on !?) can be used to set leds of the default grid, but only if it is available (if SerialOSCGrid.default is not nil)

SerialOSCGrid.default !? { |grid| grid.ledSet(1, 2, true) };


// Now, on handling multiple devices

// Info on what device triggered a GridKeydef is available in the function argument list.
GridKeydef(\debug, { |x, y, state, time, device| [x, y, state, time, device].debug });

// You can use a device as filter. See OSCdef help for how this works.
GridKeydef(\debug, { |x, y, state, time, device| [x, y, state, time, device].debug }, device: SerialOSCGrid.default);

// If several devices are attached you can retrieve SerialOSCGrid and SerialOSCEnc instances from SerialOSCClient.devices
SerialOSCClient.devices;

// Pick a device and set a led
a=SerialOSCClient.devices.first;
a.ledSet(1, 2, true); // this assumes first device in list is a grid (SerialOSCGrid)
::

subsection::Hello Grid Buttons

code::
// Make sure to attach a SerialOSC compatible grid device to your computer.

SerialOSCClient.init; // Initialize the SerialOSCClient. Connected devices get posted to the Post Window.

s.boot; // Boot server

// Hello World - pressing the top-leftmost button on any attached grid auditions a sinewave.
GridKeydef.press(\playSine, { a = {SinOsc.ar}.play }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);

// Remove GridKeydefs using .free or by pressing Cmd-.
GridKeydef.press(\playSine).free;
GridKeydef.release(\stopSine).free;
::

subsection::Hello Grid Leds

code::
// Make sure to attach a SerialOSC compatible grid device to your computer.

SerialOSCClient.init; // Initialize the SerialOSCClient. Connected devices get posted to the Post Window.

a=SerialOSCGrid.default; // First attached grid is set as default
a.ledSet(0, 0, true); // Make top-leftmost led on the default grid lit
a.ledSet(0, 0, false); // Make top-leftmost led on the default grid unlit
8 do: { a.ledSet(8.rand, 8.rand, [true, false].choose) }; // Scramble 8 random leds in a 8x8 matrix
::

subsection::Hello Scrambled World

code::
(
var scrambleLeds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, [true, false].choose) };
	};
};

GridKeydef.press(\playSineAndScrambleLeds, { a = {SinOsc.ar}.play; scrambleLeds.(); }, 0, 0);
GridKeydef.release(\stopSine, { a.release }, 0, 0);
)

GridKeydef.freeAll; // Free all responders
::

subsection::A monome and arc play together

code::
// Example, grid together with arc

(
var set_arc_led;
var scramble_8_grid_leds;
var b_spec = ControlSpec.new;

// Ensure server is running
s.serverRunning.not.if {
	Error("Boot server stored in interpreter variable s.").throw
};

// Initialize client in order to use devices
SerialOSCClient.init;

// SynthDef to server
SynthDef(\test, { |freq, gate=1| Out.ar(0, ( SinOsc.ar(Lag.kr(freq)) * EnvGen.ar(Env.cutoff, gate) ) ! 2) }).add;

// Function to visualize a float value 0 - 1.0 on first encoder ring of default arc (if attached)
set_arc_led = { |value|
	SerialOSCEnc.default !? { |enc|
		enc.clearRings;
		enc.ringSet(0, SerialOSCEnc.ledXSpec.map(value), 15);
	};
};

// Function to scramble state for 8 random buttons in a 8x8 led matrix on the default grid (if attached)
scramble_8_grid_leds = {
	SerialOSCGrid.default !? { |grid|
		8 do: { grid.ledSet(8.rand, 8.rand, [true, false].choose) };
	};
};

// Initial arc encoder setting
b = 0.5;
set_arc_led.(b);

// First Arc encoder control frequency of sinewave and scrambles 8 leds
EncDeltadef(\adjustFrequency, { |n, delta|
	b = b_spec.constrain(b + (delta/1000));
	a !? { a.set(\freq, \freq.asSpec.map(b)) };
	set_arc_led.(b);
	scramble_8_grid_leds.();
}, 0);

// Hitting any grid button auditions sinewave and scrambles 8 leds
GridKeydef.press(
	\playSine,
	{
		a ?? {
			a = Synth(\test, [\freq, \freq.asSpec.map(b)]);
			scramble_8_grid_leds.();
		};
	}
);

// Releasing any grid button stops the sinewave
GridKeydef.release(\stopSine, { a.release; a = nil });
)
::

section::Feedback

for suggestions / comments contact me

Anton Hörnquist, anton.hornquist@gmail.com.
